<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Rd to HTML Converter</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            margin: 0;
            padding: 1rem;
            background: #f7f7f9;
            color: #222;
        }

        h1 {
            margin-top: 0;
        }

        .top-bar {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .top-bar-right {
            margin-left: auto;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 0.5rem;
        }

        .layout {
            display: grid;
            grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
            gap: 1rem;
        }

        @media (max-width: 900px) {
            .layout {
                grid-template-columns: 1fr;
            }
        }

        .editor-pane {}

        .render-pane {}

        /* View-only mode: hide editor, expand renderer */
        .layout.view-mode .editor-pane {
            display: none;
        }

        .layout.view-mode .render-pane {
            grid-column: 1 / -1;
        }

        textarea {
            width: 100%;
            min-height: 350px;
            font-family: "SF Mono", Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.9rem;
            border-radius: 6px;
            border: 1px solid #ccc;
            padding: 0.5rem;
            box-sizing: border-box;
            background: #fff;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        button {
            padding: 0.4rem 0.9rem;
            border-radius: 999px;
            border: 1px solid #444;
            background: #222;
            color: #fff;
            font-size: 0.9rem;
            cursor: pointer;
        }

        button.secondary {
            background: #f0f0f0;
            color: #222;
            border-color: #bbb;
        }

        button.secondary:hover {
            background: #e2e2e2;
        }

        button:hover {
            background: #333;
        }

        input[type="file"] {
            font-size: 0.8rem;
        }

        select {
            padding: 0.25rem 0.4rem;
            border-radius: 999px;
            border: 1px solid #ccc;
            font-size: 0.85rem;
            background: #fff;
        }

        #output {
            background: #fff;
            border-radius: 6px;
            border: 1px solid #ccc;
            padding: 0.75rem 1rem;
            min-height: 350px;
            overflow: auto;
        }

        #output h1,
        #output h2,
        #output h3 {
            margin-top: 0.5rem;
        }

        code {
            background: #f0f0f0;
            padding: 0 0.15rem;
            border-radius: 3px;
            font-size: 0.9em;
        }

        pre {
            background: #111;
            color: #f5f5f5;
            padding: 0.75rem;
            border-radius: 6px;
            overflow-x: auto;
            font-size: 0.85rem;
        }

        /* Fix: code blocks inside <pre> should not have white box / background */
        pre code {
            background: transparent;
            color: inherit;
            padding: 0;
            border-radius: 0;
            font-size: inherit;
        }

        dl {
            display: grid;
            grid-template-columns: auto minmax(0, 1fr);
            column-gap: 1rem;
            row-gap: 0.25rem;
        }

        dt {
            font-weight: bold;
            white-space: nowrap;
        }

        dd {
            margin: 0;
        }

        ul,
        ol {
            padding-left: 1.25rem;
        }

        .section-title {
            margin-top: 1rem;
            border-bottom: 1px solid #ddd;
            padding-bottom: 0.2rem;
        }

        .note {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 0.5rem;
        }

        .status {
            font-size: 0.8rem;
            color: #217346;
        }

        .status.error {
            color: #b00020;
        }
    </style>
</head>

<body>
    <div class="top-bar">
        <div>
            <h1>Rd to HTML Converter</h1>
            <p class="note">
                Paste an <code>.Rd</code> (R documentation) file, upload one, or choose a sample. This parser
                supports common sections and a subset of Rd markup, rendered client-side only.
            </p>
        </div>
        <div class="top-bar-right">
            <button id="modeToggleBtn" class="secondary" type="button">Switch to View-only mode</button>
            <button id="copyLinkBtn" type="button">Copy share link</button>
            <span id="statusMsg" class="status"></span>
        </div>
    </div>

    <div id="layout" class="layout">
        <div class="editor-pane">
            <div class="controls">
                <button id="convertBtn">Convert to HTML</button>

                <label>
                    <input type="file" id="fileInput" accept=".Rd,.rd,text/plain" />
                </label>

                <select id="sampleSelect">
                    <option value="">Sample Rdâ€¦</option>
                    <option value="simpleFn">Simple function</option>
                    <option value="withLists">With itemize/enumerate</option>
                    <option value="withPreformatted">With preformatted</option>
                </select>

                <button id="clearBtn" type="button" class="secondary">Clear</button>
            </div>
            <textarea id="rdInput" placeholder="Paste your .Rd file contents here..."></textarea>
        </div>

        <div class="render-pane">
            <h2 class="section-title">Rendered HTML</h2>
            <div id="output"></div>
        </div>
    </div>

    <script>
        // --- Sample Rd snippets ---------------------------------------------------
        const SAMPLE_RDS = {
            simpleFn: `
\\name{add_one}
\\alias{add_one}
\\title{Add one to a numeric vector}
\\description{
Add one to each element of a numeric vector.
}
\\usage{
add_one(x)
}
\\arguments{
  \\item{x}{A numeric vector.}
}
\\value{
A numeric vector with 1 added to each element of \\code{x}.
}
\\details{
This is a trivial example used to demonstrate the \\code{.Rd} to HTML converter.
}
\\examples{
x <- 1:5
add_one(x)
}`,
            withLists: `
\\name{summarise_data}
\\alias{summarise_data}
\\title{Summarise a data frame}
\\description{
Compute basic summary statistics for numeric columns in a data frame.
}
\\usage{
summarise_data(x)
}
\\arguments{
  \\item{x}{A data frame.}
}
\\details{
The function returns a data frame with one row per numeric column,
containing:

\\itemize{
  \\item the column name,
  \\item the number of non-missing values,
  \\item the mean,
  \\item the standard deviation.
}

If \\code{x} has no numeric columns, an empty data frame is returned.

The function assumes that:
\\enumerate{
  \\item \\code{x} is a valid data frame;
  \\item column names are unique.
}
}
\\value{
A data frame with summary statistics for each numeric column.
}
\\examples{
df <- data.frame(a = 1:3, b = c(2, NA, 4))
summarise_data(df)
}`,
            withPreformatted: `
\\name{ascii_art}
\\alias{ascii_art}
\\title{Print a simple ASCII logo}
\\description{
Print an ASCII logo to the console.
}
\\usage{
ascii_art()
}
\\details{
This function simply uses \\code{cat()} with a
\\preformatted{
  ____    _      _      _
 / __ \\  | |    | |    | |
| |  | | | |    | |    | |
| |  | | | |    | |    | |
| |__| | | |____| |____| |____
 \\____/  |______|______|______|

}
}
\\value{
Invisibly returns \\code{NULL}.
}
\\examples{
ascii_art()
}`
        };

        // --- Utility: extract the content of a top-level macro like \title{...} ---
        function extractSection(rdText, macroName) {
            const pattern = new RegExp("\\\\" + macroName + "\\s*\\{", "m");
            const startMatch = rdText.match(pattern);
            if (!startMatch) return null;

            const startIndex = startMatch.index + startMatch[0].length;
            let i = startIndex;
            let depth = 1;
            while (i < rdText.length && depth > 0) {
                const ch = rdText[i];
                if (ch === "{") depth++;
                else if (ch === "}") depth--;
                i++;
            }
            const raw = rdText.slice(startIndex, i - 1);
            return raw.trim();
        }

        // --- Utility: extract a whole block like \arguments{ ... } including nested braces ---
        function extractBlock(rdText, macroName) {
            const pattern = new RegExp("\\\\" + macroName + "\\s*\\{", "m");
            const startMatch = rdText.match(pattern);
            if (!startMatch) return null;
            const openIndex = startMatch.index + startMatch[0].length;
            let i = openIndex;
            let depth = 1;
            while (i < rdText.length && depth > 0) {
                const ch = rdText[i];
                if (ch === "{") depth++;
                else if (ch === "}") depth--;
                i++;
            }
            const raw = rdText.slice(openIndex, i - 1);
            return raw.trim();
        }

        // --- Inline macro rendering: code/emph/strong/url/link etc. ---------------
        function renderInline(text) {
            if (!text) return "";

            // Escape HTML first
            text = text
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;");

            // Handle block-level macros embedded inside inline text first:
            text = renderListsAndPreformatted(text);

            // Now convert simple inline Rd macros
            function replaceMacro(input, macro, replacementFn) {
                const pattern = new RegExp("\\\\" + macro + "\\s*\\{", "g");
                let result = "";
                let lastIndex = 0;
                let match;

                while ((match = pattern.exec(input)) !== null) {
                    const before = input.slice(lastIndex, match.index);
                    result += before;

                    let i = pattern.lastIndex;
                    let depth = 1;
                    while (i < input.length && depth > 0) {
                        const ch = input[i];
                        if (ch === "{") depth++;
                        else if (ch === "}") depth--;
                        i++;
                    }
                    const inner = input.slice(pattern.lastIndex, i - 1);
                    const replaced = replacementFn(inner);
                    result += replaced;
                    lastIndex = i;
                    pattern.lastIndex = i;
                }

                result += input.slice(lastIndex);
                return result;
            }

            text = replaceMacro(text, "code", (inner) => "<code>" + inner + "</code>");
            text = replaceMacro(text, "emph", (inner) => "<em>" + inner + "</em>");
            text = replaceMacro(text, "strong", (inner) => "<strong>" + inner + "</strong>");
            text = replaceMacro(text, "url", (inner) => {
                const url = inner.trim();
                return '<a href="' + url + '" target="_blank" rel="noopener noreferrer">' + url + "</a>";
            });
            text = replaceMacro(text, "link", (inner) => {
                // Very simple: just render as code, no package/topic resolution.
                return "<code>" + inner.trim() + "</code>";
            });

            // Line breaks: keep double newlines as paragraphs, single as <br>
            const paragraphs = text.split(/\n{2,}/);
            const htmlParagraphs = paragraphs.map((p) =>
                p.replace(/\n/g, "<br />")
            );
            return htmlParagraphs.join("</p><p>");
        }

        // --- Block macros: \itemize{}, \enumerate{}, \preformatted{} --------------
        function renderListsAndPreformatted(text) {
            if (!text) return "";

            function replaceBlockMacro(input, macro, renderFn) {
                const pattern = new RegExp("\\\\" + macro + "\\s*\\{", "g");
                let result = "";
                let lastIndex = 0;
                let match;

                while ((match = pattern.exec(input)) !== null) {
                    const before = input.slice(lastIndex, match.index);
                    result += before;

                    let i = pattern.lastIndex;
                    let depth = 1;
                    while (i < input.length && depth > 0) {
                        const ch = input[i];
                        if (ch === "{") depth++;
                        else if (ch === "}") depth--;
                        i++;
                    }
                    const inner = input.slice(pattern.lastIndex, i - 1);
                    const replaced = renderFn(inner);
                    result += replaced;
                    lastIndex = i;
                    pattern.lastIndex = i;
                }

                result += input.slice(lastIndex);
                return result;
            }

            function renderItemize(inner) {
                // \itemize{ \item item1 \item item2 }
                const items = [];
                const itemPattern = /\\item\b/g;
                let match;
                let text = inner;
                let lastPos = 0;

                while ((match = itemPattern.exec(text)) !== null) {
                    const itemStart = match.index + match[0].length;
                    if (items.length > 0) {
                        // previous item ends at current match.index
                        const prev = text.slice(lastPos, match.index).trim();
                        if (prev) items[items.length - 1] += "\n" + prev;
                    }
                    items.push(text.slice(itemStart)); // temp; will trim when we hit next
                    lastPos = itemStart;
                }

                // Clean up items: split items array properly
                const finalItems = [];
                if (items.length) {
                    for (let idx = 0; idx < items.length; idx++) {
                        let itemText = items[idx];
                        // cut at next \item or end
                        const nextItemMatch = itemText.match(/\\item\b/);
                        if (nextItemMatch) {
                            itemText = itemText.slice(0, nextItemMatch.index);
                        }
                        itemText = itemText.trim();
                        if (itemText) finalItems.push(itemText);
                    }
                }

                if (!finalItems.length) return inner;

                let html = "<ul>";
                for (const it of finalItems) {
                    html += "<li>" + renderInline(it) + "</li>";
                }
                html += "</ul>";
                return html;
            }

            function renderEnumerate(inner) {
                // \enumerate{ \item first \item second }
                const items = [];
                const itemPattern = /\\item\b/g;
                let match;
                let text = inner;
                let lastPos = 0;

                while ((match = itemPattern.exec(text)) !== null) {
                    const itemStart = match.index + match[0].length;
                    if (items.length > 0) {
                        const prev = text.slice(lastPos, match.index).trim();
                        if (prev) items[items.length - 1] += "\n" + prev;
                    }
                    items.push(text.slice(itemStart));
                    lastPos = itemStart;
                }

                const finalItems = [];
                if (items.length) {
                    for (let idx = 0; idx < items.length; idx++) {
                        let itemText = items[idx];
                        const nextItemMatch = itemText.match(/\\item\b/);
                        if (nextItemMatch) {
                            itemText = itemText.slice(0, nextItemMatch.index);
                        }
                        itemText = itemText.trim();
                        if (itemText) finalItems.push(itemText);
                    }
                }

                if (!finalItems.length) return inner;

                let html = "<ol>";
                for (const it of finalItems) {
                    html += "<li>" + renderInline(it) + "</li>";
                }
                html += "</ol>";
                return html;
            }

            function renderPreformatted(inner) {
                const escaped = inner
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;");
                return "<pre><code>" + escaped + "</code></pre>";
            }

            let out = text;
            out = replaceBlockMacro(out, "itemize", renderItemize);
            out = replaceBlockMacro(out, "enumerate", renderEnumerate);
            out = replaceBlockMacro(out, "preformatted", renderPreformatted);

            return out;
        }

        // --- Parse \arguments{ \item{x}{desc} ... } into <dl> ---------------------
        function renderArgumentsBlock(blockText) {
            if (!blockText) return "";

            const items = [];
            let text = blockText;
            const itemPattern = /\\item\s*\{/g;
            let match;

            while ((match = itemPattern.exec(text)) !== null) {
                let nameStart = itemPattern.lastIndex;
                let i = nameStart;
                let depth = 1;
                while (i < text.length && depth > 0) {
                    const ch = text[i];
                    if (ch === "{") depth++;
                    else if (ch === "}") depth--;
                    i++;
                }
                const name = text.slice(nameStart, i - 1).trim();
                // description
                if (text[i] !== "{") {
                    // skip whitespace/newline until next "{"
                    while (i < text.length && text[i] !== "{") i++;
                    if (i >= text.length) break;
                }
                let descStart = i + 1;
                let j = descStart;
                depth = 1;
                while (j < text.length && depth > 0) {
                    const ch = text[j];
                    if (ch === "{") depth++;
                    else if (ch === "}") depth--;
                    j++;
                }
                const desc = text.slice(descStart, j - 1).trim();
                itemPattern.lastIndex = j;

                items.push({ name, desc });
            }

            if (!items.length) return "";

            let html = "<dl>";
            for (const item of items) {
                html +=
                    "<dt>" +
                    renderInline(item.name) +
                    "</dt><dd><p>" +
                    renderInline(item.desc) +
                    "</p></dd>";
            }
            html += "</dl>";
            return html;
        }

        // --- Parse \examples{ ... } into <pre><code> ------------------------------
        function renderExamplesBlock(blockText) {
            if (!blockText) return "";
            // Strip \dontrun{} and \donttest{} wrappers very naively
            blockText = blockText.replace(/\\dontrun\s*\{([\s\S]*?)\}/g, "$1");
            blockText = blockText.replace(/\\donttest\s*\{([\s\S]*?)\}/g, "$1");

            const escaped = blockText
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;");
            return "<pre><code>" + escaped + "</code></pre>";
        }

        // --- Top-level converter: Rd text -> HTML --------------------------------
        function parseRdToHtml(rdText) {
            if (!rdText || !rdText.trim()) {
                return "<p><em>No Rd input.</em></p>";
            }

            let html = "";

            const name = extractSection(rdText, "name");
            const title = extractSection(rdText, "title") || name;
            const description = extractBlock(rdText, "description") || extractSection(rdText, "description");
            const usage = extractBlock(rdText, "usage") || extractSection(rdText, "usage");
            const argumentsBlock = extractBlock(rdText, "arguments");
            const value = extractBlock(rdText, "value") || extractSection(rdText, "value");
            const details = extractBlock(rdText, "details") || extractSection(rdText, "details");
            const examplesBlock = extractBlock(rdText, "examples");

            if (title) {
                html += "<h1>" + renderInline(title) + "</h1>";
            }
            if (name) {
                html += "<p><strong>Name:</strong> <code>" + renderInline(name) + "</code></p>";
            }

            if (description) {
                html += '<h2 class="section-title">Description</h2><p>' + renderInline(description) + "</p>";
            }

            if (usage) {
                const escapedUsage = usage
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;");
                html += '<h2 class="section-title">Usage</h2><pre><code>' + escapedUsage + "</code></pre>";
            }

            if (argumentsBlock) {
                html += '<h2 class="section-title">Arguments</h2>';
                html += renderArgumentsBlock(argumentsBlock);
            }

            if (value) {
                html += '<h2 class="section-title">Value</h2><p>' + renderInline(value) + "</p>";
            }

            if (details) {
                html += '<h2 class="section-title">Details</h2><p>' + renderInline(details) + "</p>";
            }

            if (examplesBlock) {
                html += '<h2 class="section-title">Examples</h2>';
                html += renderExamplesBlock(examplesBlock);
            }

            if (!html) {
                html = "<p><em>No known Rd sections found. Is this a valid Rd file?</em></p>";
            }

            return html;
        }

        // --- Mode handling (edit vs view-only) -----------------------------------
        const layout = document.getElementById("layout");
        const modeToggleBtn = document.getElementById("modeToggleBtn");
        let currentMode = "edit"; // "edit" or "view"

        function setMode(mode) {
            currentMode = mode;
            if (mode === "view") {
                layout.classList.add("view-mode");
                modeToggleBtn.textContent = "Back to edit mode";
                modeToggleBtn.classList.remove("secondary");
            } else {
                layout.classList.remove("view-mode");
                modeToggleBtn.textContent = "Switch to View-only mode";
                modeToggleBtn.classList.add("secondary");
            }
        }

        modeToggleBtn.addEventListener("click", () => {
            setMode(currentMode === "edit" ? "view" : "edit");
        });

        // --- Wire up UI ----------------------------------------------------------
        const rdInput = document.getElementById("rdInput");
        const output = document.getElementById("output");
        const convertBtn = document.getElementById("convertBtn");
        const fileInput = document.getElementById("fileInput");
        const clearBtn = document.getElementById("clearBtn");
        const sampleSelect = document.getElementById("sampleSelect");
        const copyLinkBtn = document.getElementById("copyLinkBtn");
        const statusMsg = document.getElementById("statusMsg");

        function convertCurrent() {
            const rdText = rdInput.value;
            const html = parseRdToHtml(rdText);
            output.innerHTML = html;
        }

        convertBtn.addEventListener("click", () => {
            convertCurrent();
        });

        clearBtn.addEventListener("click", () => {
            rdInput.value = "";
            output.innerHTML = "";
            fileInput.value = "";
            sampleSelect.value = "";
            setStatus("");
        });

        fileInput.addEventListener("change", (event) => {
            const file = event.target.files && event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                rdInput.value = e.target.result;
                convertCurrent();
            };
            reader.readAsText(file);
        });

        sampleSelect.addEventListener("change", () => {
            const key = sampleSelect.value;
            if (!key) return;
            const rd = SAMPLE_RDS[key];
            rdInput.value = rd.trimStart();
            convertCurrent();
        });

        function setStatus(msg, type = "ok") {
            statusMsg.textContent = msg;
            statusMsg.classList.remove("error");
            if (type === "error") statusMsg.classList.add("error");
            if (msg) {
                setTimeout(() => {
                    if (statusMsg.textContent === msg) statusMsg.textContent = "";
                }, 2500);
            }
        }

        // --- Shareable link: encode Rd in URL and copy ---------------------------
        copyLinkBtn.addEventListener("click", async () => {
            const rdText = rdInput.value || "";
            const encoded = encodeURIComponent(rdText);
            const baseUrl = window.location.origin + window.location.pathname;
            const url = baseUrl + "?rd=" + encoded + "&mode=view";

            try {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(url);
                    setStatus("Share link copied!");
                } else {
                    // Fallback
                    const dummy = document.createElement("textarea");
                    dummy.value = url;
                    document.body.appendChild(dummy);
                    dummy.select();
                    document.execCommand("copy");
                    document.body.removeChild(dummy);
                    setStatus("Share link copied!");
                }
            } catch (e) {
                console.error(e);
                setStatus("Could not copy link", "error");
            }
        });

        // --- On load: read rd + mode from URL params -----------------------------
        (function initFromUrl() {
            const params = new URLSearchParams(window.location.search);
            const rdParam = params.get("rd");
            const modeParam = params.get("mode");

            if (rdParam !== null) {
                // URLSearchParams already decodes percent-encoding
                rdInput.value = rdParam;
                convertCurrent();
            }

            if (modeParam === "view" && rdParam !== null) {
                setMode("view");
            } else {
                setMode("edit");
            }
        })();
    </script>
</body>

</html>